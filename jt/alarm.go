package jt

import (
	"github.com/xaces/xproto"
)

// 位 定义 处理说明
// 0 1：紧急报警，触动报警开关后触发 收到应答后清零
// 1 1：超速报警 标志维持至报警条件解除
// 2 1：疲劳驾驶 标志维持至报警条件解除
// 3 1：危险预警 收到应答后清零
// 4 1：GNSS 模块发生故障 标志维持至报警条件解除
// 5 1：GNSS 天线未接或被剪断 标志维持至报警条件解除
// 6 1：GNSS 天线短路 标志维持至报警条件解除
// 7 1：终端主电源欠压 标志维持至报警条件解除
// 8 1：终端主电源掉电 标志维持至报警条件解除
// 9 1：终端 LCD 或显示器故障 标志维持至报警条件解除
// 10 1：TTS 模块故障 标志维持至报警条件解除
// 11 1：摄像头故障 标志维持至报警条件解除
// 12 1：道路运输证 IC 卡模块故障 标志维持至报警条件解除
// 13 1：超速预警 标志维持至报警条件解除
// 14 1：疲劳驾驶预警 标志维持至报警条件解除
// 15-17 保留
// 18 1：当天累计驾驶超时 标志维持至报警条件解除
// 19 1：超时停车 标志维持至报警条件解除
// 20 1：进出区域 收到应答后清零
// 21 1：进出路线 收到应答后清零
// 22 1：路段行驶时间不足/过长 收到应答后清零
// 23 1：路线偏离报警 标志维持至报警条件解除
// 24 1：车辆 VSS 故障 标志维持至报警条件解除
// 25 1：车辆油量异常 标志维持至报警条件解除
// 26 1：车辆被盗(通过车辆防盗器) 标志维持至报警条件解除
// 27 1：车辆非法点火 收到应答后清零
// 28 1：车辆非法位移 收到应答后清零
// 29 1：碰撞预警 标志维持至报警条件解除
// 30 1：侧翻预警 标志维持至报警条件解除
// 31 1：非法开门报警（终端未设置区域时，不判断非法开门） 收到应答后清零

// 超速报警附加信息消息体数据格式
// 起始字节 字段 数据类型 描述及要求
// 0 位置类型 BYTE
// 0：无特定位置；
// 1：圆形区域；
// 2：矩形区域；
// 3：多边形区域；
// 4：路段
// 1 区域或路段 ID DWORD 若位置类型为 0，无该字段

// 进出区域/路线报警附加信息消息体数据格式
// 起始字节 字段 数据类型 描述及要求
// 0 位置类型 BYTE
// 1：圆型区域；
// 2：矩形区域；
// 3：多边形区域；
// 4：路线
// 1 区域或线路 ID DWORD
// 5 方向 BYTE 0：进；
// 1：出

// 路线行驶时间不足/过长报警附加信息消息体数据格式
// 起始字节 字段 数据类型 描述及要求
// 0 路段 ID DWORD
// 4 路段行驶时间 WORD 单位为秒（s）
// 6 结果 BYTE 0：不足；1：过长

// 表 36 人工确认报警类型定义
// 位 定义
// 0 1：确认紧急报警；
// 1-2 保留
// 3 1：确认危险预警；
// 4-19 保留
// 20 1：确认进出区域报警；
// 21 1：确认进出路线报警；
// 22 1：确认路段行驶时间不足/过长报警；
// 23-26 保留
// 27 1：确认车辆非法点火报警；
// 28 1：确认车辆非法位移报警；
// 29-31 保留
func (p *Client) toAlarm(alrflag uint32, st *xproto.Status, b *jtBytes) (alr *xproto.Alarm) {
	alr.Tag = "jAlr"
	alr.DeviceNo = p.DeviceNo
	alr.Status = st
	ack := false
	for i := 0; i < 32; i++ {
		if (alrflag>>i)&0x01 <= 0 {
			continue
		}
		switch i {
		case 0:
			alr.Type = xproto.Alarm_Urgency
		case 1:
			alr.Type = xproto.Alarm_OverSpeed
			t := b.toByte()
			if t > 0 {
				b.toDWord()
			}
		case 2:
			alr.Type = xproto.Alarm_Urgency
		case 3:
		}
		break
	}
	// TODO部分告警需要确认
	if ack {
		var res jtBytes
		res.addWord(p.sequence)
		res.addDWord(alrflag)
		p.writeMessage(0x8203, res.Bytes)
	}
	return
}
